rd_("BbX coordinates slice (up to len()).BbY coordinates slice (up to len()).BbZ coordinates slice (up to len()).BcI/O error (socket, file operations)BeLength of the header in bytes/octets.BlLength of the column header in bytes/octets.BiLength of the data block in bytes/octets.BfIMU data (accelerometer and gyroscope)BnNumber of valid points currently in the frame.B`Get the current number of pointsAjGet the number of packets.DgCreate a new <code>ClusterData</code> using HashMap-based spatial hash.CiCreate a new Points structure with pre-allocated capacityCgCreate a new frame with default capacity for Ouster \xe2\x80\xa6CaCreate a new Ouster driver from sensor parametersC`Create a new UDP source from an existing socket.C`Create a new test source with the given packets.BaCreate a new looping test source.CnCreate a new frame with default capacity for Robosense E1R \xe2\x80\xa6BaCreate a new Robosense E1R driverCmNIR photons related to natural environmental illumination \xe2\x80\xa6A`Dual return modeBhgPTP (IEEE 802.1AS) time synchronizationA`Last return modeBkBind to an address and create a UDP source.BfGet the number of columns in the frameAgGet the crop boundariesAoReturns the argument unchanged.00000000000000000000000000000000000000BaCalls <code>U::from(self)</code>.00000000000000000000000000000000000000Bl<code>table_size - 1</code> for fast modulo.AjPush a point to the frame.CaReceive the next packet into the provided buffer.BcGet the number of rows in the frameBfCommon error type for LiDAR operationsBcShape error from ndarray operationsClTwo-pass build: count points per voxel, compute offsets, \xe2\x80\xa6BiClear all points while retaining capacityCeGet reference to the depth buffer (zero-copy access).C`Depth buffer owned by FrameReader - never copiedB`Create an empty Points structureAlCreate an empty test source.CiHorizontal coordinates for polar binning [h0, h1] per \xe2\x80\xa6CmCommon LiDAR types and trait abstraction for multi-sensor \xe2\x80\xa6CmRange from sensor in meters (provided by sensor protocol, \xe2\x80\xa6CjScratch buffer for range values (internal units before \xe2\x80\xa6CfRange in millimeters, discretized to the nearest 1 \xe2\x80\xa6CmReset frame for new data (sets point index to 0, does NOT \xe2\x80\xa6BbReset the source to the beginning.AcConfiguration errorA`Time sync failedAnOuster OS series LiDAR sensorsBnPoint cloud output structure (sensor-agnostic)AlPTP E2E time synchronizationCbbeam_to_lidar Z offset (cached for SIMD broadcast)BfReturns the column at the given index.CbRemove ground-plane points from the validity mask.CgIMU-guided ground plane removal for LiDAR point clouds.AhGyroscope X-axis (rad/s)AhGyroscope Y-axis (rad/s)AhGyroscope Z-axis (rad/s)BcOuster LiDAR driver implementation.CnIndicates validity of the measurements. Status is true for \xe2\x80\xa6CiProcess a UDP packet, accumulating data into internal \xe2\x80\xa6BkIMU data from DIFOP packets (bytes 208-231)AhSeeds per patch for PCA.AhPolar grid: range rings.AcNearest return modeAdTime sync successfulAaTime sync timeoutAlAccelerometer X-axis (m/s\xc2\xb2)AlAccelerometer Y-axis (m/s\xc2\xb2)AlAccelerometer Z-axis (m/s\xc2\xb2)Cc3D Spatial Hash DBSCAN clustering for point clouds.CjPoint cloud formatting with architecture-specific SIMD \xe2\x80\xa6CjPer-point height along gravity (dot(point, gravity_unit)).ClInitialization ID. Updates on every reinit, which may be \xe2\x80\xa6BhPacket sequence number (wraps per frame)C`Process UDP packet data into the provided frame.CgGet reference to the reflect buffer (zero-copy access).CgReflectivity buffer owned by FrameReader - never copiedCjSensor Signal Photons measurements are scaled based on \xe2\x80\xa6BbSet the valid length of the frame.CgPre-flattened x_range coefficients (for r * x_coeff \xe2\x80\xa6CgPre-flattened y_range coefficients (for r * y_coeff \xe2\x80\xa6CkPre-flattened altitude coefficients (sin of altitude angle)AjInternal oscillator timingCbCurrent capacity (max points before reallocation).BoRun DBSCAN clustering on the given point cloud.BfFrame sequence ID (wraps at u32::MAX).C`Get the frame_id of the current/completed frame.CmIndex of the lidar scan, increments every time the sensor \xe2\x80\xa6BhCurrent frame ID (increments each frame)BdCheck if more packets are available.CmFxHash-style hash for voxel keys: wrapping multiply + XOR \xe2\x80\xa6BeReturns true if no points are stored.nCheck if emptyoCheck if empty.A`Local IP addressDdCreate a new <code>ClusterData</code> using flat-array spatial hash.BcScratch buffer for seed extraction.AmPre-flattened x_delta offsetsAmPre-flattened y_delta offsetsAnTemporal EMA smoothing factor.BgMax horizontal range for grid (meters).BdMinimum seeds for a valid PCA patch.BnMSOP packet sync bytes: 0x55, 0xaa, 0x5a, 0xa5AlPolar grid: azimuth sectors.nTotal patches.AjRobosense E1R LiDAR sensorAeStrongest return modeCcUDP socket packet source for live sensor operation.EeFind a slot for <code>key</code> (read-only lookup). Returns <code>None</code> if \xe2\x80\xa6BlIntensity/reflectivity values (up to len()).AeMSOP destination portBjRobosense E1R LiDAR driver implementation.BeGet current timestamp in nanoseconds.AoFrame timestamp in nanoseconds.CaGet the timestamp of the current/completed frame.BlTimestamp of the measurement in nanoseconds.B`Size of each data block in bytesAgDIFOP packet sync bytesBeDevice information from DIFOP packetsChTrait for LiDAR frame data (Structure-of-Arrays layout).AnParsed MSOP header informationBjReturn mode values from MSOP header byte 8AlSensor type for CLI dispatchAaSystem time errorBdTest packet source for unit testing.CkMinimum neighbors for a point to propagate (expand) the \xe2\x80\xa6CfMinimum points for a voxel to propagate during BFS \xe2\x80\xa6AfDIFOP destination portAjSoftware version (3 bytes)BmCurrent table capacity (always a power of 2).CbReusable state for spatial hash DBSCAN clustering.BkUnified driver trait for all LiDAR sensors.BlMinimum range for ground detection (meters).Cb3D spatial hash for O(1) average neighbor queries.BfVoxel key per slot (SENTINEL = empty).CjGet mutable access to all buffers at once for SIMD writes.AnGet current device informationAmDevice information from DIFOPCbTrue when a complete frame is ready for processingBbVoxel key at the given table slot.CnFrame was completed on previous call; next call must reset \xe2\x80\xa6CmIdentifies lidar data vs. other packets in stream. Packet \xe2\x80\xa6ChParse a single data block and add the point to the frameBfRange delta for coordinate calculationAkGet the current return modeAlReturn mode from MSOP headerkReturn modeCjSource indices: linear index into packet depth/reflect \xe2\x80\xa6AlLiDAR temperature in Celsius0CiBFS queue storing dirty_bucket indices (not table slots).CnPoint cloud coordinate calculator with pre-computed lookup \xe2\x80\xa6AoIMU-guided ground plane filter.CkOuster LiDAR driver implementing the common LidarDriver \xe2\x80\xa6AiTrait for packet sources.B`Time synchronization mode valuesCbAlert flags is a bitmask of various sensor alerts.CdWhether to filter noisy points (PointAttribute == 2)BhWhether we\xe2\x80\x99ve received any packets yetCgFrame reader for packet parsing (owns depth/reflect \xe2\x80\xa6C`Last packet count (for frame boundary detection)BfParse MSOP header and extract metadataAlPer-patch point index lists.DeResize the table to <code>new_size</code> (must be a power of 2). \xe2\x80\xa6AjSet the frame sequence ID.BnEigendecomposition of a 3\xc3\x973 symmetric matrix.AhTimestamp in nanosecondsCiProcess depth and reflectivity data into XYZ point cloud.AcInvalid packet dataBmUnexpected end of data at given byte positionB`Number of points in each bucket.CnCompute default validity mask: marks (0,0,0) origin points \xe2\x80\xa6BiNumber of points in the given table slot.AfGet the current index.BjGet the current loop index (wraps around).BiDetect ground height using per-patch PCA.BkIndices of occupied buckets for fast clear.BiFrame builder for point cloud computationCfBuild an orthonormal frame from a gravity unit vector.BmCurrent smoothed ground height (if detected).BlPacket source abstraction for LiDAR drivers.BcContiguous per-voxel point indices.BmProcess a DIFOP packet for device informationCmSerial number of the sensor. This value is unique to each \xe2\x80\xa6AdDevice serial numberBaGet serial number as a hex stringBgSet the frame timestamp in nanoseconds.CaIndicates the shot limiting status of the sensor.DeReverse map: table slot \xe2\x86\x92 index into <code>dirty_buckets</code> \xe2\x80\xa6AiTime synchronization modeCiRun voxel connected-component clustering on the given \xe2\x80\xa6BfPer-dirty-bucket visited flag for BFS.BkCreate a new frame with specified capacity.0CeBuffer overflow (too many points for buffer capacity)C`Point field data types for PointCloud2 messages.AjRange ring width (meters).AkTime synchronization statusBkToo many columns in frame (Ouster-specific)CkWrite cursor per bucket (used during scatter pass, then \xe2\x80\xa6ClStart index into <code>point_indices</code> for each bucket.ClSequentially incrementing measurement counting up from 0 \xe2\x80\xa6BaNumber of occupied voxel buckets.CmSet the bridge threshold \xe2\x80\x94 minimum neighbors for a core \xe2\x80\xa6CdGet software version as a string (e.g., \xe2\x80\x9c1.2.3\xe2\x80\x9d)BiScale factor for direction vectors (2^15)BoFlatness: smallest eigenvalue ratio below this.CdFlat-array spatial hash with open-addressing and \xe2\x80\xa6ChMaximum load factor before table must grow. At 0.75, \xe2\x80\xa6CjMaximum UDP packet size for Ouster sensors (OS1-128 at \xe2\x80\xa6AjRobosense E1R LiDAR driverBlUnsupported number of rows (Ouster-specific)CnCompute eigenvector for a 3\xc3\x973 symmetric matrix at a given \xe2\x80\xa6DfEnsure the table is large enough for <code>n_points</code> without \xe2\x80\xa6BgPoint indices for the given table slot.BoIndicates whether thermal shutdown is imminent.CkStart a new frame after the previous one has been consumed.AkTime synchronization statusAlAzimuth bin width (radians).CmFirst cluster ID available for real clusters (2, 3, 4, \xe2\x80\xa6\xe2\x80\xa6CcReserved cluster ID for noise (invalid returns, \xe2\x80\xa6C`Internal trait for drivers to write into frames.AiMSOP header size in bytesAoMSOP packet total size in bytesBjOuster-specific LidarFrame implementation.BkExpected points per frame (~26,000 at 10Hz)ChReusable state for voxel connected-component clustering.BbSet whether to filter noisy pointsBeNumber of data blocks per MSOP packetBlReserved cluster ID for ground plane points.AaDIFOP packet sizeCfLooping test source that repeats packets indefinitely.AcUnknown packet typeAgUnsupported data formatBgSlot index of the i-th occupied bucket.BhTemporally-smoothed ground height (EMA).CcCheck if this packet indicates a new frame boundaryCdUprightness: |normal_z| must exceed this (cos 32\xc2\xb0).CkReverse-lookup: find the dirty_bucket index for a given \xe2\x80\xa6BaEdgeFirst LiDAR Publisher LibraryCgPre-allocated buffer for packet that triggers frame \xe2\x80\xa6CnLength of valid data in pending_packet_buf (0 = no pending \xe2\x80\xa6BcDistance resolution in meters (5mm)CmElevation tolerance: reject patches whose centroid height \xe2\x80\xa6BoInsufficient columns in frame (Ouster-specific)BmRobosense-specific LidarFrame implementation.DjFind or insert a slot for <code>key</code> via linear probing. Returns \xe2\x80\xa6CcMinimum accepted patches to trust ground detection.CbBuild the clustered point fields (17-byte stride).CmFormat point cloud data into 13-byte packed format (XYZ + \xe2\x80\xa6CmInsert a key into the table without checking load factor. \xe2\x80\xa6CiFormat clustered point cloud data into 17-byte packed \xe2\x80\xa6CcScalar fallback for non-aarch64 targets without \xe2\x80\xa6ChCalculate XYZ coordinates using scalar code, writing \xe2\x80\xa6BcScalar fallback for clustered data.ClBuild the standard XYZ + intensity point fields (13-byte \xe2\x80\xa6")